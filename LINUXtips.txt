[ DAY 1 ]

-rw-rw---- = Quando não possui inicial significa que é um executavel
drw-rw---- = A Inicial "d" significa que é um diretório
lrw-rw---- = A Inicial "l" significa que é um Symbolic Link, resumindo de forma inchuta é um atalho
brw-rw---- = A Inicial "b" significa que é um dispositivo de bloco, aquele que armazena informação como um HD, SSD, Pen-Drive etc.
crw-rw---- = A Inicial "c" é dispositivo de caracter, é um dispositivo que está recebendo e enviando informação, terminal (tty), impressora (lp), mouse (psaux) é um exemplo disso.

[ DAY 2 ]

FHS

/bin = São os binários todos os arquivos executaveis, são os comandos do linux (ls, cat, vi, vim, etc) 
/boot = São os arquivos essenciais para a inicialização do sistema *Curiosidade (o kernel fica no /boot, o nome dele é vmlinuz)
/dev = Vem de device, fica todos os dispositivos do sistema (HD, SDD, Mouse, Impressora, Pen-Drive, Teclado, Terminais e por ai vai)
/etc = É o diretório que terá todos os arquivos de configurações globais. 
/home = É o diretório que tem a home dos usuarios.
/lib = Bibliotecas essenciais do sistema, de binários localizados em /bin e /sbin (Um exemplo são os drivers)
/mnt = Sistema de arquivos montado temporariamente
/lost+found = Arquivos para recuperação, geralmente gerado por uma queda de energia ou fechamento inadequado, serve para ser recuperado.
/opt = Antigamente o opt era onde ficava armazenados os pacotes de instalação de softwares
/proc = É um diretório virtual onde tem arquivos com informações de todo sistema, CPU, Memoria, Disposito de Caracter, Dispositivo de Bloco entre outros.
/root = É o diretório do usuário root (super usuario), onde tem todas as informações do mesmo
/run = É um diretório com informações temporaria, ele mostra tudo que esta rodando de fundo, pessoas que estão logadas.
/sbin = A diferença do bin e o sbin, é que o sbin é referente ao Superusuario (root), então são comando que só ele tem permissão pra utilizar.
/srv = Arquivos relacionados a servidores, dados estáticos.
/sys = Trás informações do sistema na parte de HARDWARE de forma mais organizada e estática.
/tmp = É um diretório temporaria, tudo que esta armazenado dele após o PC ser desligado, ele apaga (NÃO RECOMENDADO COLOCAR BACKUP NELE)
/usr = É o segundo maior diretório perdendo apenas para o diretorío raiz, ele tem a mesma função que o raiz faz as separações, mas de arquivos que não interfira no funcionamento do Linux em si.
/var = É um diretório de variáveis, trás informações de log, debugs e por ai vai.

[ DAY 3 ]

Um comando interno é, é um comando que esta dentro do interpretador do próprio Shell, e é mais rapido que o comado externo.
Um comando externo é, um comando que esta fora do interpretador e fizemos alguns macetes para colocar.

- which <comando>: Vai mostrar onde está o comando.
- whereis <comando>: Vai mostrar onde está o comando.
- type <comando>: Vai informar que tipo de comando é esse, se ele é interno (shell builtin), alias ou externo (hashed).

- ls --color=auto: Ele vai colocar cores em arquivos respectivamente conforme o seu tipo (terminal ja faz isso automaticamente), temos outras variantes como --color=never para nunca colocar cores
- ls -B: Ele NÃO lista os arquivos Backups (Arquivos backups por convenção são aqueles que termina com "~" ex: teste1~)
- ls <pasta1> <pasta2>: Ele consegue fazer ls consecutivamente em pasta diferentes se você apontar a pasta que deverá ser feito o ls.
- ls -d <pasta1> <pasta2>: Ele consegue filtrar as duas pasta e trazer apenas o ls delas, é igual o | grep
- ls -ln: Ele lista tudo e em vez de trazer o nome do usuario:grupo, ele traz UID:GID no lugar de nome e grupo.
- ls -F: Indica se é link simbolico (atalho@) se é arquivo executavel (executavel*) e se é diretório (diretorio/)

- mkdir -p: consegue criar varios diretorios dentro do outro (ex: mkdir diretorio1/diretorio2 e por ai vai)
- tree: Mostra toda a estrutura da pasta em formato de arvore
- tree -A: Mostra de forma mais limpa, (USAR SOMENTE SE O TERMINAL MOSTRAR DE FORMA ZOADA)
- tree -h: Vai mostrar o tamanho dos diretórios, de forma humana
- tree <pasta>: Vai mostrar em formato de arvore o que tem no arquivo, lembra o packages do Java.

- cat -n: Vai ler o arquivo porém com numero de linhas
- cat -b: Vai ler o arquivo e vai contar o numero de linhas, porém ele ignora as linhas em brancos para contagem.
- cat -E: Vai ler o arquivo e coloca um "$" no final de cada linha, assim facilitando se tem espaço em branco no final da linha.
- cat -T: Vai ler o arquivo e identifica cada identeção feita pelo Tab, reconhecida como (^I)

- zcat: Vai ler o arquivo.gz, evitando que precise descompactar para fazer a leitura
- bzcat: Vai ler o arquivo.bz2, evitando que precise descompactar para fazer a leitura
- xzcat: Vai ler o arquivo.xz, evitando que precise descompactar para fazer a leitura
- tac: Vai ler o arquivo com as linhas invertidas.

- rm -i: Ele pergunta antes de fazer a ação de excluir, isso pode trazer mais segurança.

** DICA: Quando tivermos arquivos que tem a mesma inicial e queremos apagar apenas esses arquivos em especifico exemplo: arquivo1 arquivo2 arquivo3, podemos fazer "rm -rf arqui*" **

- cp -R: O parametro -R ele consegue copiar arquivos de dispositivos, ja o -r ignora os arquivos de dispositivos.
- cp -s <diretorio/arquivo> <nome_do_link_simbolico>: Cria link simbolico, extamente a mesma coisa que o ln -s, apenas uma forma diferente.
- cp -a: Equivale a cp -dpR, é recomendavel utilizar se for uma copia com extrema zatidão pra evitar problemas, ele copia literalmente da forma mais perfeita, geralmente utilizada pra transferir pra outro linux

[ DAY 4 ]

Coringas:

*Lembrando que coloquei o comando "ls" para facilitar, mas pode ser usado em outras situações claramente* 

*Coringa "*" *
- ls <inicial>*: Vai retornar todos os arquivos com a inicial digitada exemplo arquivo*
- ls *<final>: Vai retornar todos os arquivos com os finais digitados exemplo *.txt
- ls <inicial>*<final>: Vai retornar arquivo com a inicial digitado e o final digital exemplo: a*r

*Coringa "?" *

- ls m?: Vai retornar todos os arquivos com dois caracteres, pois o "?" e a string que esta faltando porém e desconhecida, logo retornara todas as strings que poderia ser pra preencher.
- ls ?m: Mesma coisa que o de cima só que em ordem diferente, podemos usar o ? para varias ordens

podemos misturar coringas exemplo: ls a?t*: nesse exemplo provavelmente retornaria o apt já que o ? do meio pode ser preenchido por qualquer string e depois * que trará todo o resultado com esse filtro.

*Coringa "[]" *

O [] ele consegue preencher de uma letra até outra especificada

- ls m[a-c]: Ele vai filtrar o proximo caracter que esta faltando dentro desse range de [a-c]
- ls m[^a-c]: É o contrario, ele vai filtrar o proximo caracter que não seja entre [a-c] o "^" é como fosse negação tipo um "not" no python

sort: É um comando que consegue trazer de forma em ordem alfabetica as linhas ex: sort <arquivo>
sort -r: Ele consegue deixar de forma invertida do sorte normal.
sort -n: É um comando que traz em ordem alfabetica e em ordem númerica do menor para o maior.
sort -c: Ele avisa se esta ordenado ou não.